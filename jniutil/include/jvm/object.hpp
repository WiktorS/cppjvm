#ifndef JVM_OBJECT_INCLUDED
#define JVM_OBJECT_INCLUDED

#include <jni.h>

#include "jniutil.hpp"

namespace jvm
{
	/*	This class wraps a JNI object reference. Note that it is not
		anything like a reference-counted smart pointer: it does not
		do anything to manage object lifetimes.

		Instead, you most use java::local_frame to create contexts
		in which local references can be acquired, and outside of
		which they automatically become invalid.

		The reason this class is needed at all is so that we have
		a uniform interface that can be overridden by global<T>,
		which does manage lifetimes much like a reference-counted
		smart pointer.

		Most application code doesn't need to use this class
		directly. Instead, use the derived wrapper classes that are
		auto-generated by the CppWrap tool.
	*/
	class object
	{
		jobject m_object;

	public:
		explicit object(jobject o = 0)
			: m_object(o) {}

		jobject get_impl() const
			{ return m_object; }

		void put_impl(jobject o)
			{ m_object = o; }

		jclass get_class() const;

		bool is_null() const
			{ return m_object == 0; }

        void set_null()
            { m_object = 0; }

	protected:
		void make_global();
		void delete_global();
	};

	// Used to distinguish the default contructor in generated wrappers
	enum new_t { new_ };

	// Equivalent of the Java 'new' operator for up to 8 parameters
	template <class TNew>
	TNew jnew()
	{
		TNew o;
		o.new_();
		return o;
	}

	template <class TNew, class TArg1>
	TNew jnew(const TArg1 &a1)
	{
		TNew o;
		o.new_(a1);
		return o;
	}

	template <class TNew, class TArg1, class TArg2>
	TNew jnew(const TArg1 &a1, const TArg2 &a2)
	{
		TNew o;
		o.new_(a1, a2);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3)
	{
		TNew o;
		o.new_(a1, a2, a3);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3, class TArg4>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3, const TArg4 &a4)
	{
		TNew o;
		o.new_(a1, a2, a3, a4);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3, 
		  class TArg4, class TArg5>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3, 
		  const TArg4 &a4, const TArg5 &a5)
	{
		TNew o;
		o.new_(a1, a2, a3, a4, a5);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3, class TArg4, 
		  class TArg5, class TArg6>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3, const TArg4 &a4, 
		  const TArg5 &a5, const TArg6 &a6)
	{
		TNew o;
		o.new_(a1, a2, a3, a4, a5, a6);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3, class TArg4, 
		  class TArg5, class TArg6, class TArg7>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3, const TArg4 &a4, 
		  const TArg5 &a5, const TArg6 &a6, const TArg7 &a7)
	{
		TNew o;
		o.new_(a1, a2, a3, a4, a5, a6, a7);
		return o;
	}

	template <class TNew, class TArg1, class TArg2, class TArg3, class TArg4, 
		  class TArg5, class TArg6, class TArg7, class TArg8>
	TNew jnew(const TArg1 &a1, const TArg2 &a2, const TArg3 &a3, const TArg4 &a4, 
		  const TArg5 &a5, const TArg6 &a6, const TArg7 &a7, const TArg8 &a8)
	{
		TNew o;
		o.new_(a1, a2, a3, a4, a5, a6, a7, a8);
		return o;
	}
}

#endif
